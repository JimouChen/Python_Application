"""
# @Time    :  2020/6/19
# @Author  :  Jimou Chen
"""
import numpy as np

'''
已知递推公式：
F(n, 1)=F(n-1, 2) + 2F(n-3, 1) + 5,
F(n, 2)=F(n-1, 1) + 3F(n-3, 1) + 2F(n-3, 2) + 3.

初始值为：F(1, 1)=2, F(1, 2)=3, F(2, 1)=1, F(2, 2)=4, F(3, 1)=6, F(3, 2)=5。
输入n，输出F(n, 1)和F(n, 2)，由于答案可能很大，你只需要输出答案除以99999999的余数。
输入第一行包含一个整数n。
输出两行，第一行为F(n, 1)除以99999999的余数，第二行为F(n, 2)除以99999999的余数。
Key:
构造一个1×8的矩阵[f(n-1,1),f(n-1,2),f(n-2,1),f(n-2,2),f(n-3,1),f(n-3,2),5,3]
，根据递推关系，可以通过乘以一个8×8的矩阵A，得到矩阵[f(n,1),f(n,2),f(n-1,1),f(n-1,2),f(n-2,1),f(n-2,2),5,3]，算出矩阵A，

以下做法是不考虑负数的
'''

A = np.array([[0, 1, 1, 0, 0, 0, 0, 0],
              [1, 0, 0, 1, 0, 0, 0, 0],
              [0, 0, 0, 0, 1, 0, 0, 0],
              [0, 0, 0, 0, 0, 1, 0, 0],
              [2, 3, 0, 0, 0, 0, 0, 0],
              [0, 2, 0, 0, 0, 0, 0, 0],
              [1, 0, 0, 0, 0, 0, 1, 0],
              [0, 1, 0, 0, 0, 0, 0, 1]])

a = np.array([0, 2, 1, 6])
b = np.array([0, 3, 4, 5])
n = int(input())
modNum = 99999999

for i in range(3, n + 1):
    # [a[i + 1], b[i + 1], a[i], b[i], a[i - 1], b[i - 1], 1]
    nextArray = np.dot([a[i], b[i], a[i - 1], b[i - 1], a[i - 2], b[i - 2], 5, 3], A)
    nextA = nextArray[0] % modNum % modNum
    nextB = nextArray[1] % modNum % modNum
    a = np.append(a, nextA)
    b = np.append(b, nextB)

print(a[n])
print(b[n], end='\n')
